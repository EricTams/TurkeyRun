// AIDEV-NOTE: Procedural generation system (chunk 6, refactored chunks 10A/11).
// Loads curve-based section patterns from js/data/patterns.json (generated by
// tools/generate_sections.py). Each pattern defines a safe path, obstacles
// outside the path, and optional bird spawn points. Coins are placed along
// the safe path at runtime. Birds spawn as pattern elements rather than on
// an independent timer. Ground hazard subTypes are replaced at runtime with
// the current biome's hazard types (chunk 11).

import {
    CANVAS_WIDTH, GROUND_Y, PIXELS_PER_METER,
    ZAPPER_GAP_MARGIN,
    SPAWNER_GRACE_DISTANCE, SPAWNER_BASE_GAP, SPAWNER_MIN_GAP,
    SPAWNER_GAP_SHRINK_RATE, SPAWNER_EASY_COUNT,
    SPAWNER_HARD_FROM, SPAWNER_EXTREME_FROM, SPAWNER_EXTREME_DOMINANT,
    BIRD_HEIGHT,
    LASER_BEAM_THICKNESS, LASER_STATIC_WIDTH,
    LASER_SWEEP_SPEED, LASER_SWEEP_ARC,
    PATH_COIN_SPACING
} from './config.js';
import {
    createGroundHazard, updateGroundHazard, isOffScreen
} from './hazards/groundHazard.js';
import {
    createZapperAt, createBottomOpenZapper, updateZapper, isZapperOffScreen
} from './hazards/zapper.js';
import {
    createBird, updateBird, isBirdOffScreen
} from './hazards/bird.js';
import {
    createStaticLaser, createSweepLaser,
    updateLaser, isLaserOffScreen
} from './hazards/laser.js';
import { spawnCoinsAtPositions } from './collectible.js';
import { generateCoinsOnPath } from './sectionPath.js';
import { getBiomeGroundHazards } from './biome.js';

// ---------------------------------------------------------------------------
// Pattern pool -- loaded from JSON
// ---------------------------------------------------------------------------

let POOL_BY_TIER = { easy: [], medium: [], hard: [], extreme: [] };
let patternsLoaded = false;

export async function loadPatterns() {
    try {
        const resp = await fetch('./js/data/patterns.json');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        POOL_BY_TIER = {
            easy:    data.easy    || [],
            medium:  data.medium  || [],
            hard:    data.hard    || [],
            extreme: data.extreme || []
        };
        patternsLoaded = true;
    } catch (err) {
        console.error('Failed to load patterns.json, using empty pools:', err);
        patternsLoaded = false;
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function resolveGapY(gapCenter, gapH) {
    const clamped = Math.max(0, Math.min(1, gapCenter));
    const available = GROUND_Y - 2 * ZAPPER_GAP_MARGIN - gapH;
    return ZAPPER_GAP_MARGIN + available * clamped;
}

function resolveBeamY(beamCenter) {
    const margin = LASER_BEAM_THICKNESS + 10;
    const clamped = Math.max(0, Math.min(1, beamCenter));
    return margin + (GROUND_Y - 2 * margin) * clamped;
}

function pickRandom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function randomBirdY() {
    const margin = 20;
    return margin + Math.random() * (GROUND_Y - BIRD_HEIGHT - 2 * margin);
}

// ---------------------------------------------------------------------------
// Tier selection -- first N patterns are easy, then ramps through tiers
// ---------------------------------------------------------------------------

function selectTier(distanceMeters, patternCount) {
    // First SPAWNER_EASY_COUNT patterns are always easy
    if (patternCount < SPAWNER_EASY_COUNT) {
        return 'easy';
    }

    const roll = Math.random();

    // After easy period: medium dominates, with increasing hard/extreme
    if (distanceMeters < SPAWNER_HARD_FROM) {
        return roll < 0.15 ? 'easy' : 'medium';
    }
    if (distanceMeters < SPAWNER_EXTREME_FROM) {
        if (roll < 0.10) return 'easy';
        if (roll < 0.45) return 'medium';
        return 'hard';
    }
    if (distanceMeters < SPAWNER_EXTREME_DOMINANT) {
        if (roll < 0.05) return 'easy';
        if (roll < 0.25) return 'medium';
        if (roll < 0.60) return 'hard';
        return 'extreme';
    }
    // Beyond EXTREME_DOMINANT: mostly extreme/hard
    if (roll < 0.05) return 'medium';
    if (roll < 0.35) return 'hard';
    return 'extreme';
}

// ---------------------------------------------------------------------------
// Gap between patterns -- shrinks with distance for increasing density
// ---------------------------------------------------------------------------

function getGapForDistance(distanceMeters) {
    const shrink = (distanceMeters / 1000) * SPAWNER_GAP_SHRINK_RATE;
    return Math.max(SPAWNER_MIN_GAP, SPAWNER_BASE_GAP - shrink);
}

// ---------------------------------------------------------------------------
// Spawn a single pattern element into the appropriate array
// ---------------------------------------------------------------------------

// Current distance in meters, updated each frame by updateSpawner()
let currentDistanceMeters = 0;

function spawnElement(elem, groundArr, zapperArr, laserArr) {
    if (elem.type === 'ground') {
        // Pick a biome-appropriate ground hazard type instead of the
        // pattern's hardcoded subType (which is always beach-biome).
        const biomeHazards = getBiomeGroundHazards(currentDistanceMeters);
        const subType = pickRandom(biomeHazards);
        const hazard = createGroundHazard(subType);
        hazard.x = CANVAS_WIDTH + elem.offsetX;
        groundArr.push(hazard);
        return;
    }
    if (elem.type === 'zapper') {
        const gapY = resolveGapY(elem.gapCenter, elem.gapH);
        zapperArr.push(createZapperAt(CANVAS_WIDTH + elem.offsetX, gapY, elem.gapH));
        return;
    }
    if (elem.type === 'zapperBottomOpen') {
        zapperArr.push(createBottomOpenZapper(CANVAS_WIDTH + elem.offsetX, elem.barHeight));
        return;
    }
    if (elem.type === 'laserStatic') {
        const beamY = resolveBeamY(elem.beamCenter);
        const width = elem.beamWidth || LASER_STATIC_WIDTH;
        laserArr.push(createStaticLaser(CANVAS_WIDTH + elem.offsetX, beamY, width));
        return;
    }
    if (elem.type === 'laserSweep') {
        const pivotY = elem.pivotSide === 'ceiling' ? 0 : GROUND_Y;
        const halfArc = LASER_SWEEP_ARC / 2;
        const centerAngle = elem.pivotSide === 'ceiling' ? Math.PI / 2 : -Math.PI / 2;
        laserArr.push(createSweepLaser(
            CANVAS_WIDTH + elem.offsetX,
            pivotY,
            centerAngle - halfArc,
            centerAngle + halfArc,
            LASER_SWEEP_SPEED
        ));
    }
}

// ---------------------------------------------------------------------------
// Spawn a full pattern: obstacles, coins on path, birds
// ---------------------------------------------------------------------------

function spawnPattern(pattern) {
    // Spawn obstacle elements
    for (const elem of pattern.elements) {
        spawnElement(elem, hazards, zappers, lasers);
    }

    // Spawn coins along the safe path
    if (pattern.path && pattern.path.length >= 2) {
        const coinPositions = generateCoinsOnPath(pattern.path, CANVAS_WIDTH, PATH_COIN_SPACING);
        spawnCoinsAtPositions(coinPositions);
    }

    // Spawn birds from pattern bird definitions
    if (pattern.birds) {
        for (const birdDef of pattern.birds) {
            birds.push(createBird(randomBirdY()));
        }
    }
}

// Get the total width of a pattern (last path waypoint x, or 200 fallback)
function getPatternWidth(pattern) {
    if (pattern.path && pattern.path.length > 0) {
        return pattern.path[pattern.path.length - 1].x;
    }
    return 200;
}

// ---------------------------------------------------------------------------
// Spawner state
// ---------------------------------------------------------------------------

let nextSpawnDistancePx = 0;
let hazards = [];
let zappers = [];
let birds = [];
let lasers = [];
let patternCount = 0;

export function resetSpawner() {
    nextSpawnDistancePx = SPAWNER_GRACE_DISTANCE;
    hazards = [];
    zappers = [];
    birds = [];
    lasers = [];
    patternCount = 0;
    currentDistanceMeters = 0;
}

export function updateSpawner(dt, distancePx, turkeyCenterX, turkeyCenterY) {
    if (!patternsLoaded) return;

    const distanceMeters = Math.floor(distancePx / PIXELS_PER_METER);
    currentDistanceMeters = distanceMeters;

    // Spawn next pattern when distance threshold is reached
    if (distancePx >= nextSpawnDistancePx) {
        const tier = selectTier(distanceMeters, patternCount);
        const pool = POOL_BY_TIER[tier];
        if (pool.length > 0) {
            const pattern = pickRandom(pool);
            spawnPattern(pattern);
            patternCount++;
            const width = getPatternWidth(pattern);
            nextSpawnDistancePx = distancePx + width + getGapForDistance(distanceMeters);
        }
    }

    // Update and cull ground hazards
    for (const h of hazards) {
        updateGroundHazard(h, dt);
    }
    hazards = hazards.filter(h => !isOffScreen(h));

    // Update and cull zappers
    for (const z of zappers) {
        updateZapper(z, dt);
    }
    zappers = zappers.filter(z => !isZapperOffScreen(z));

    // Update and cull lasers
    for (const l of lasers) {
        updateLaser(l, dt);
    }
    lasers = lasers.filter(l => !isLaserOffScreen(l));

    // Update and cull birds
    for (const b of birds) {
        updateBird(b, dt, turkeyCenterX, turkeyCenterY);
    }
    birds = birds.filter(b => !isBirdOffScreen(b));
}

export function getHazards() {
    return hazards;
}

export function getZappers() {
    return zappers;
}

export function getBirds() {
    return birds;
}

export function getLasers() {
    return lasers;
}
