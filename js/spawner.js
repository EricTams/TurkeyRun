// AIDEV-NOTE: Procedural generation system (chunk 6, refactored chunks 10A/11).
// Loads curve-based section patterns from js/data/patterns.json (generated by
// tools/generate_sections.py). Each pattern defines a safe path, obstacles
// outside the path, and optional bird spawn points. Coins are placed along
// the safe path at runtime. Birds spawn as pattern elements rather than on
// an independent timer. Ground hazard subTypes are replaced at runtime with
// the current biome's hazard types (chunk 11).

import {
    AUTO_RUN_SPEED,
    CANVAS_WIDTH, GROUND_Y, PIXELS_PER_METER,
    ZAPPER_GAP_MARGIN,
    SPAWNER_GRACE_DISTANCE, SPAWNER_BASE_GAP, SPAWNER_MIN_GAP,
    SPAWNER_GAP_SHRINK_RATE,
    SPAWNER_HARD_FROM, SPAWNER_EXTREME_FROM, SPAWNER_EXTREME_DOMINANT, BIRD_HEIGHT,
    PATH_COIN_SPACING, FOOD_SIZE, PLAYER_START_X, BOAR_PATTERN_CHANCE
} from './config.js';
import {
    createGroundHazard, updateGroundHazard, isOffScreen
} from './hazards/groundHazard.js';
import {
    createZapperAt, createBottomOpenZapper, updateZapper, isZapperOffScreen
} from './hazards/zapper.js';
import {
    createBird, updateBird, isBirdOffScreen
} from './hazards/bird.js';
import {
    createSkyBlocker, updateSkyBlocker, isSkyBlockerOffScreen
} from './hazards/skyBlocker.js';
import { spawnCoinsAtPositions } from './collectible.js';
import { generateCoinsOnPath } from './sectionPath.js';
import { getBiomeGroundHazards, getBiomeSkyBlockers, getCurrentBiomeName } from './biome.js';
import {
    updateLaserPattern,
    isLaserPatternActive,
    startLaserPattern,
    stopLaserPattern,
    getSafeCenterBandsAtTime,
} from './laserPattern.js';
import { LASER_PATTERNS_BY_TIER } from './data/laserPatterns.js';
import { addTerrainSegment, updateTerrain, resetTerrain } from './terrain.js';

// ---------------------------------------------------------------------------
// Pattern pool -- loaded from JSON
// ---------------------------------------------------------------------------

let POOL_BY_TIER = { easy: [], medium: [], hard: [], extreme: [] };
let patternsLoaded = false;

export async function loadPatterns() {
    try {
        const resp = await fetch('./js/data/patterns.json');
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        POOL_BY_TIER = {
            easy:    data.easy    || [],
            medium:  data.medium  || [],
            hard:    data.hard    || [],
            extreme: data.extreme || []
        };
        patternsLoaded = true;
    } catch (err) {
        console.error('Failed to load patterns.json, using empty pools:', err);
        patternsLoaded = false;
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function resolveGapY(gapCenter, gapH) {
    const clamped = Math.max(0, Math.min(1, gapCenter));
    const available = GROUND_Y - 2 * ZAPPER_GAP_MARGIN - gapH;
    return ZAPPER_GAP_MARGIN + available * clamped;
}

function pickRandom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function randomBirdY() {
    const margin = 20;
    return margin + Math.random() * (GROUND_Y - BIRD_HEIGHT - 2 * margin);
}

function selectBirdTypeForPattern(tier) {
    if (tier !== 'hard' && tier !== 'extreme') return 'grackle';
    return Math.random() < BOAR_PATTERN_CHANCE ? 'boar' : 'grackle';
}

const BIOME_NOODLE_ANIM = {
    beach:     'poolNoodleSpin3',
    grass:     'poolNoodleSpin1',
    mountain:  'poolNoodleSpin1',
    moon:      'poolNoodleSpin3',
    spiritual: 'poolNoodleSpin2',
};

function getNoodleAnimKey() {
    const biome = getCurrentBiomeName(currentDistanceMeters);
    return BIOME_NOODLE_ANIM[biome] || 'poolNoodleSpin1';
}

function getLaserSectionChance(tier) {
    if (tier === 'medium') return 0.15;
    if (tier === 'hard') return 0.28;
    if (tier === 'extreme') return 0.4;
    return 0;
}

function getLaserSectionDistancePx(pattern) {
    // Screen-space laser patterns are time-based; convert duration to
    // approximate world distance for pacing between sections.
    const durationPx = pattern.duration * AUTO_RUN_SPEED;
    return Math.max(300, durationPx * 0.85);
}

function pickLargestBandCenterY(bands) {
    if (!bands || bands.length === 0) return null;
    let best = bands[0];
    let bestHeight = best.hi - best.lo;
    for (let i = 1; i < bands.length; i++) {
        const band = bands[i];
        const height = band.hi - band.lo;
        if (height > bestHeight) {
            best = band;
            bestHeight = height;
        }
    }
    return best.lo + (best.hi - best.lo) * 0.5;
}

function clampCoinY(y) {
    const minY = FOOD_SIZE / 2;
    const maxY = GROUND_Y - FOOD_SIZE;
    return Math.max(minY, Math.min(y, maxY));
}

function generateCoinsForLaserPattern(pattern) {
    const sampleDt = PATH_COIN_SPACING / AUTO_RUN_SPEED;
    if (sampleDt <= 0 || pattern.duration <= 0) return [];

    const coins = [];
    const collectibleEndLeadSeconds = 0.8;
    const maxSampleTime = Math.max(sampleDt, pattern.duration - collectibleEndLeadSeconds);
    const dedupeX = Math.max(1, Math.floor(PATH_COIN_SPACING * 0.5));
    let lastBucketX = -Infinity;
    for (let t = sampleDt; t < maxSampleTime; t += sampleDt) {
        // Spawn so each coin reaches player column (x=PLAYER_START_X) at sample time t.
        const x = PLAYER_START_X + t * AUTO_RUN_SPEED;
        const xBucket = Math.floor(x / dedupeX);
        if (xBucket === lastBucketX) continue;
        const safeBands = getSafeCenterBandsAtTime(pattern, t);
        const centerY = pickLargestBandCenterY(safeBands);
        if (centerY === null) continue;
        coins.push({ x, y: clampCoinY(centerY - FOOD_SIZE * 0.5) });
        lastBucketX = xBucket;
    }
    return coins;
}

function maybeSpawnLaserSection(tier) {
    const pool = LASER_PATTERNS_BY_TIER[tier] || [];
    if (pool.length === 0) return null;
    if (isLaserPatternActive()) return null;
    if (Math.random() >= getLaserSectionChance(tier)) return null;
    const pattern = pickRandom(pool);
    startLaserPattern(pattern);
    const coinPositions = generateCoinsForLaserPattern(pattern);
    if (coinPositions.length > 0) {
        spawnCoinsAtPositions(coinPositions);
    }
    return pattern;
}

// ---------------------------------------------------------------------------
// Tier selection -- ramps by run distance
// ---------------------------------------------------------------------------

function selectTier(distanceMeters) {
    // Early run starts easy by distance, then ramps through tiers.
    if (distanceMeters < SPAWNER_HARD_FROM * 0.25) {
        return 'easy';
    }

    const roll = Math.random();

    // After easy period: medium dominates, with increasing hard/extreme
    if (distanceMeters < SPAWNER_HARD_FROM) {
        return roll < 0.15 ? 'easy' : 'medium';
    }
    if (distanceMeters < SPAWNER_EXTREME_FROM) {
        if (roll < 0.10) return 'easy';
        if (roll < 0.45) return 'medium';
        return 'hard';
    }
    if (distanceMeters < SPAWNER_EXTREME_DOMINANT) {
        if (roll < 0.05) return 'easy';
        if (roll < 0.25) return 'medium';
        if (roll < 0.60) return 'hard';
        return 'extreme';
    }
    // Beyond EXTREME_DOMINANT: mostly extreme/hard
    if (roll < 0.05) return 'medium';
    if (roll < 0.35) return 'hard';
    return 'extreme';
}

// ---------------------------------------------------------------------------
// Gap between patterns -- shrinks with distance for increasing density
// ---------------------------------------------------------------------------

function getGapForDistance(distanceMeters) {
    const shrink = (distanceMeters / 1000) * SPAWNER_GAP_SHRINK_RATE;
    return Math.max(SPAWNER_MIN_GAP, SPAWNER_BASE_GAP - shrink);
}

// ---------------------------------------------------------------------------
// Spawn a single pattern element into the appropriate array
// ---------------------------------------------------------------------------

// Current distance in meters, updated each frame by updateSpawner()
let currentDistanceMeters = 0;

function spawnElement(elem, groundArr, zapperArr, skyArr) {
    if (elem.type === 'ground') {
        // Pick a biome-appropriate ground hazard type instead of the
        // pattern's hardcoded subType (which is always beach-biome).
        const biomeHazards = getBiomeGroundHazards(currentDistanceMeters);
        const subType = pickRandom(biomeHazards);
        const hazard = createGroundHazard(subType);
        hazard.x = CANVAS_WIDTH + elem.offsetX;
        groundArr.push(hazard);
        return;
    }
    if (elem.type === 'skyBlocker' || elem.type === 'skyBlockerSmall') {
        const biomeSky = getBiomeSkyBlockers(currentDistanceMeters);
        if (biomeSky.length > 0) {
            const blocker = createSkyBlocker(pickRandom(biomeSky), elem.y);
            blocker.x = CANVAS_WIDTH + elem.offsetX;
            skyArr.push(blocker);
        }
        return;
    }
    if (elem.type === 'zapper') {
        const gapY = resolveGapY(elem.gapCenter, elem.gapH);
        zapperArr.push(createZapperAt(CANVAS_WIDTH + elem.offsetX, gapY, elem.gapH, getNoodleAnimKey()));
        return;
    }
    if (elem.type === 'zapperBottomOpen') {
        zapperArr.push(createBottomOpenZapper(CANVAS_WIDTH + elem.offsetX, elem.barHeight, getNoodleAnimKey()));
        return;
    }
    // Legacy section lasers are intentionally disabled.
    if (elem.type === 'laserStatic' || elem.type === 'laserSweep') {
        return;
    }
}

// ---------------------------------------------------------------------------
// Spawn a full pattern: obstacles, coins on path, birds
// ---------------------------------------------------------------------------

function spawnPattern(pattern, tier) {
    // Spawn terrain elevation segment
    if (pattern.elevation && pattern.elevation.length > 0) {
        addTerrainSegment(pattern.elevation, CANVAS_WIDTH);
    }

    // Spawn obstacle elements (ground hazards, zappers, sky blockers)
    for (const elem of pattern.elements) {
        spawnElement(elem, hazards, zappers, skyBlockers);
    }

    // Spawn coins along the safe path
    if (pattern.path && pattern.path.length >= 2) {
        const coinPositions = generateCoinsOnPath(pattern.path, CANVAS_WIDTH, PATH_COIN_SPACING);
        spawnCoinsAtPositions(coinPositions);
    }

    // Spawn birds from pattern bird definitions
    if (pattern.birds) {
        const birdType = selectBirdTypeForPattern(tier);
        for (const _birdDef of pattern.birds) {
            birds.push(createBird(randomBirdY(), birdType));
        }
    }
}

// Get the total width of a pattern (last path waypoint x, or 200 fallback)
function getPatternWidth(pattern) {
    if (pattern.path && pattern.path.length > 0) {
        return pattern.path[pattern.path.length - 1].x;
    }
    return 200;
}

// ---------------------------------------------------------------------------
// Spawner state
// ---------------------------------------------------------------------------

let nextSpawnDistancePx = 0;
let hazards = [];
let zappers = [];
let birds = [];
let skyBlockers = [];

export function resetSpawner() {
    nextSpawnDistancePx = SPAWNER_GRACE_DISTANCE;
    hazards = [];
    zappers = [];
    birds = [];
    skyBlockers = [];
    currentDistanceMeters = 0;
    stopLaserPattern();
    resetTerrain();
}

export function updateSpawner(dt, distancePx, turkeyCenterX, turkeyCenterY) {
    if (!patternsLoaded) return;

    updateTerrain(dt);

    const distanceMeters = Math.floor(distancePx / PIXELS_PER_METER);
    currentDistanceMeters = distanceMeters;

    // Spawn next pattern when distance threshold is reached
    if (distancePx >= nextSpawnDistancePx) {
        const tier = selectTier(distanceMeters);
        const laserPattern = maybeSpawnLaserSection(tier);
        if (laserPattern) {
            const width = getLaserSectionDistancePx(laserPattern);
            nextSpawnDistancePx = distancePx + width + getGapForDistance(distanceMeters);
        } else {
            const pool = POOL_BY_TIER[tier];
            if (pool.length > 0) {
                const pattern = pickRandom(pool);
                spawnPattern(pattern, tier);
                const width = getPatternWidth(pattern);
                nextSpawnDistancePx = distancePx + width + getGapForDistance(distanceMeters);
            }
        }
    }

    // Update and cull ground hazards
    for (const h of hazards) {
        updateGroundHazard(h, dt);
    }
    hazards = hazards.filter(h => !isOffScreen(h));

    // Update and cull zappers
    for (const z of zappers) {
        updateZapper(z, dt);
    }
    zappers = zappers.filter(z => !isZapperOffScreen(z));

    // Update active laser section pattern (if any)
    if (isLaserPatternActive()) {
        updateLaserPattern(dt);
    }

    // Update and cull sky blockers
    for (const sb of skyBlockers) {
        updateSkyBlocker(sb, dt);
    }
    skyBlockers = skyBlockers.filter(sb => !isSkyBlockerOffScreen(sb));

    // Update and cull birds
    for (const b of birds) {
        updateBird(b, dt, turkeyCenterX, turkeyCenterY);
    }
    birds = birds.filter(b => !isBirdOffScreen(b));
}

export function jumpSpawnerToDistance(distancePx) {
    const clampedDistancePx = Math.max(0, distancePx);
    const distanceMeters = Math.floor(clampedDistancePx / PIXELS_PER_METER);
    currentDistanceMeters = distanceMeters;

    hazards = [];
    zappers = [];
    birds = [];
    skyBlockers = [];
    stopLaserPattern();
    resetTerrain();

    nextSpawnDistancePx = clampedDistancePx + getGapForDistance(distanceMeters);
}

export function getHazards() {
    return hazards;
}

export function getZappers() {
    return zappers;
}

export function getBirds() {
    return birds;
}

export function getSkyBlockers() {
    return skyBlockers;
}

export function getLasers() {
    return [];
}
